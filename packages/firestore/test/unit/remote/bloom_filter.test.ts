/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { expect } from 'chai';

import { BloomFilter } from '../../../src/remote/bloom_filter';
import { ByteString } from '../../../src/util/byte_string';

import * as TEST_DATA from './bloom_filter_golden_test_data';

describe('BloomFilter', () => {
  it('can instantiate an empty bloom filter', () => {
    const bloomFilter = new BloomFilter(new Uint8Array(0), 0, 0);
    expect(bloomFilter.getSize()).to.equal(0);
  });

  it('should throw error if empty bloom filter inputs are invalid', () => {
    try {
      new BloomFilter(new Uint8Array(0), 1, 0);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: A valid empty bloom filter will have all three fields be empty.'
        )
      ).to.be.true;
    }
    try {
      new BloomFilter(new Uint8Array(0), 0, 1);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: A valid empty bloom filter will have all three fields be empty.'
        )
      ).to.be.true;
    }
  });

  it('can instantiate a non empty bloom filter', () => {
    const bloomFilter = new BloomFilter(
      new Uint8Array([151, 153, 236, 116, 7]),
      3,
      13
    );
    expect(bloomFilter.getSize()).to.equal(37);
  });

  it('should throw error if padding is invalid', () => {
    try {
      new BloomFilter(new Uint8Array(1), -1, 1);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Invalid padding: -1'
        )
      ).to.be.true;
    }
    try {
      new BloomFilter(new Uint8Array(1), 9, 1);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Invalid padding: 9'
        )
      ).to.be.true;
    }
  });

  it('should throw error if hash count is negative', () => {
    try {
      new BloomFilter(new Uint8Array(1), 1, -1);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Invalid hash count: -1'
        )
      ).to.be.true;
    }
  });

  it('should throw error if hash count is 0 for non empty bloom filter', () => {
    try {
      new BloomFilter(new Uint8Array(1), 1, 0);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Invalid hash count: 0'
        )
      ).to.be.true;
    }
  });

  it('mightContain in empty bloom filter should always return false', () => {
    const bloomFilter = new BloomFilter(new Uint8Array(0), 0, 0);
    expect(bloomFilter.mightContain('abc')).to.be.false;
    expect(bloomFilter.mightContain('def')).to.be.false;
  });

  it('mightContain should always return false for empty string', () => {
    const emptyBloomFilter = new BloomFilter(new Uint8Array(0), 0, 0);
    const nonEmptyBloomFilter = new BloomFilter(
      new Uint8Array([70, 204, 25]),
      1,
      16
    );
    expect(emptyBloomFilter.mightContain('')).to.be.false;
    expect(nonEmptyBloomFilter.mightContain('')).to.be.false;
  });

  /**
   * Golden tests are generated by backend based on inserting n number of
   * documents path into a bloom filter.
   *
   * Full document path is generated by concating documentPrefix and number n,
   * ie, projects/project-1/databases/database-1/documents/coll/doc12
   *
   * The test result is generated by checking the membership of documents from
   * documentPrefix+0 to documentPrefix+2n. The membership results from 0 to n
   * is expected to be true (1), and the membership results from n to 2n is
   * expected to be false (0) with some false positive results (1).
   *
   * The test result of BloomFilter.mightContain() should match the backend
   * result exactly.
   */
  describe('BloomFilter membership test', () => {
    const documentPrefix =
      'projects/project-1/databases/database-1/documents/coll/doc';

    interface TestDataType {
      bits: {
        bitmap?: string;
        padding?: number;
      };
      hashCount?: number;
    }

    interface TestResultType {
      membershipTestResults: string;
    }

    function decodeBase64ToUint8Array(encoded: string): Uint8Array {
      return ByteString.fromBase64String(encoded).toUint8Array();
    }

    function testBloomFilterAgainstExpectedResult(
      bloomFilterInputs: TestDataType,
      expectedResult: TestResultType
    ): void {
      const { bits, hashCount } = bloomFilterInputs;
      const { membershipTestResults } = expectedResult;

      const bloomFilter = new BloomFilter(
        decodeBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    }

    it('mightContain result for 1 document with 1 false positive rate', () => {
      const testData = TEST_DATA.testDataCount1Rate1 as TestDataType;
      const testResult = TEST_DATA.testResultCount1Rate1 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 1 document with 0.01 false positive rate', () => {
      const testData = TEST_DATA.testDataCount1Rate01 as TestDataType;
      const testResult = TEST_DATA.testResultCount1Rate01 as TestResultType;

      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 1 document with 0.0001 false positive rate', () => {
      const testData = TEST_DATA.testDataCount1Rate0001 as TestDataType;
      const testResult = TEST_DATA.testResultCount1Rate0001 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 500 documents with 1 false positive rate', () => {
      const testData = TEST_DATA.testDataCount500Rate1 as TestDataType;
      const testResult = TEST_DATA.testResultCount500Rate1 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 500 documents with 0.01 false positive rate', () => {
      const testData = TEST_DATA.testDataCount500Rate01 as TestDataType;
      const testResult = TEST_DATA.testResultCount500Rate01 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 500 document with 0.0001 false positive rate', () => {
      const testData = TEST_DATA.testDataCount500Rate0001 as TestDataType;
      const testResult = TEST_DATA.testResultCount500Rate0001 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 5000 documents with 1 false positive rate', () => {
      const testData = TEST_DATA.testDataCount5000Rate1 as TestDataType;
      const testResult = TEST_DATA.testResultCount5000Rate1 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 5000 documenta with 0.01 false positive rate', () => {
      const testData = TEST_DATA.testDataCount5000Rate01 as TestDataType;
      const testResult = TEST_DATA.testResultCount5000Rate01 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 5000 documenta with 0.0001 false positive rate', () => {
      const testData = TEST_DATA.testDataCount5000Rate0001 as TestDataType;
      const testResult =
        TEST_DATA.testResultCount5000Rate0001 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 50000 documents with 1 false positive rate', () => {
      const testData = TEST_DATA.testDataCount50000Rate1 as TestDataType;
      const testResult = TEST_DATA.testResultCount50000Rate1 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
    });
    it('mightContain result for 50000 documents with 0.01 false positive rate', () => {
      const testData = TEST_DATA.testDataCount50000Rate01 as TestDataType;
      const testResult = TEST_DATA.testResultCount50000Rate01 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
      //Extend default timeout(2000)
    }).timeout(10_000);

    it('mightContain result for 50000 documents with 0.0001 false positive rate', () => {
      const testData = TEST_DATA.testDataCount50000Rate0001 as TestDataType;
      const testResult =
        TEST_DATA.testResultCount50000Rate0001 as TestResultType;
      testBloomFilterAgainstExpectedResult(testData, testResult);
      //Extend default timeout(2000)
    }).timeout(10_000);
  });
});
