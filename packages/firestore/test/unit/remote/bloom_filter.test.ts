/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { expect } from 'chai';

import { BloomFilter } from '../../../src/remote/bloom_filter';

import {
  testDataCount1Rate0001,
  testDataCount1Rate01,
  testDataCount1Rate1,
  testDataCount50000Rate0001,
  testDataCount50000Rate01,
  testDataCount50000Rate1,
  testDataCount5000Rate0001,
  testDataCount5000Rate01,
  testDataCount5000Rate1,
  testDataCount500Rate0001,
  testDataCount500Rate01,
  testDataCount500Rate1,
  testResultCount1Rate0001,
  testResultCount1Rate01,
  testResultCount1Rate1,
  testResultCount50000Rate0001,
  testResultCount50000Rate01,
  testResultCount50000Rate1,
  testResultCount5000Rate0001,
  testResultCount5000Rate01,
  testResultCount5000Rate1,
  testResultCount500Rate0001,
  testResultCount500Rate01,
  testResultCount500Rate1
} from './bloom_filter_golden_test_data';

describe('BloomFilter', () => {
  it('can initiate an empty BloomFilter', () => {
    const bloomFilter = new BloomFilter(
      /* bitmap */ new Uint8Array(0),
      /* padding */ 0,
      /* hashCount */ 0
    );
    expect(bloomFilter.getBitSize()).to.equal(0);
  });

  it('can initiate a non empty BloomFilter', () => {
    const bloomFilter = new BloomFilter(
      /* bitmap */ new Uint8Array([151, 153, 236, 116, 7]),
      /* padding */ 3,
      /* hashCount */ 13
    );
    expect(bloomFilter.getBitSize()).to.equal(37);
  });

  it('should throw error if padding is negative', () => {
    try {
      new BloomFilter(new Uint8Array(0), -1, 0);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Padding is negative.'
        )
      ).to.be.true;
    }
  });

  it('should throw error if bitmap size is negative', () => {
    try {
      new BloomFilter(new Uint8Array(0), 1, 0);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Bitmap size is negative.'
        )
      ).to.be.true;
    }
  });

  it('should throw error if hash count is negative', () => {
    try {
      new BloomFilter(new Uint8Array(0), 0, -1);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Hash count is negative.'
        )
      ).to.be.true;
    }
  });

  it('mightContain in empty bloom filter should always return false', () => {
    const bloomFilter = new BloomFilter(new Uint8Array(0), 0, 0);
    expect(bloomFilter.mightContain('abc')).to.be.false;
    expect(bloomFilter.mightContain('def')).to.be.false;
  });

  it('mightContain should always return false for empty string', () => {
    const emptyBloomFilter = new BloomFilter(new Uint8Array(0), 0, 0);
    const nonEmptyBloomFilter = new BloomFilter(
      new Uint8Array([151, 153, 236, 116, 7]),
      3,
      13
    );
    expect(emptyBloomFilter.mightContain('')).to.be.false;
    expect(nonEmptyBloomFilter.mightContain('')).to.be.false;
  });

  /**
   * Golden tests are generated by backend based on inserting n number of
   * documents path into Bloom filter.
   *
   * Full documents path is generated by concating documentPrefix and n, ie,
   * projects/project-1/databases/database-1/documents/coll/doc11
   *
   * The test result is generated by checking the membership of documents from
   * documentPrefix+0 to documentPrefix+2n. The membership results from 0 to n
   * is expected to be 1, and from n to 2n to be 0 with some false positive results.
   *
   * The test result of BloomFilter.mightContain() should match the backend result
   * exactly.
   */
  describe('BloomFilter membership test', () => {
    const documentPrefix =
      'projects/project-1/databases/database-1/documents/coll/doc';

    interface TestDataType {
      bits: {
        bitmap?: string;
        padding?: number;
      };
      hashCount?: number;
    }

    interface TestResultType {
      membershipTestResults: string;
    }

    function convertBase64ToUint8Array(base64: string): Uint8Array {
      return Uint8Array.from(atob(base64), item => item.charCodeAt(0));
    }

    it('mightContain result for 1 document with 1 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount1Rate1 as TestDataType;
      const { membershipTestResults } = testResultCount1Rate1 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 1 document with 0.01 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount1Rate01 as TestDataType;
      const { membershipTestResults } =
        testResultCount1Rate01 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 1 document with 0.0001 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount1Rate0001 as TestDataType;
      const { membershipTestResults } =
        testResultCount1Rate0001 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 500 documents with 1 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount500Rate1 as TestDataType;
      const { membershipTestResults } =
        testResultCount500Rate1 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 500 documents with 0.01 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount500Rate01 as TestDataType;
      const { membershipTestResults } =
        testResultCount500Rate01 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 500 document with 0.0001 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount500Rate0001 as TestDataType;
      const { membershipTestResults } =
        testResultCount500Rate0001 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 5000 documents with 1 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount5000Rate1 as TestDataType;
      const { membershipTestResults } =
        testResultCount5000Rate1 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 5000 documenta with 0.01 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount5000Rate01 as TestDataType;
      const { membershipTestResults } =
        testResultCount5000Rate01 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 5000 documenta with 0.0001 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount5000Rate0001 as TestDataType;
      const { membershipTestResults } =
        testResultCount5000Rate0001 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 50000 documents with 1 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount50000Rate1 as TestDataType;
      const { membershipTestResults } =
        testResultCount50000Rate1 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
    });
    it('mightContain result for 50000 documents with 0.01 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount50000Rate01 as TestDataType;
      const { membershipTestResults } =
        testResultCount50000Rate01 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
      //Extend default timeout(2000)
    }).timeout(3000);

    it('mightContain result for 50000 documents with 0.0001 false positive rate should match backend result', () => {
      const { bits, hashCount } = testDataCount50000Rate0001 as TestDataType;
      const { membershipTestResults } =
        testResultCount50000Rate0001 as TestResultType;

      const bloomFilter = new BloomFilter(
        convertBase64ToUint8Array(bits.bitmap || ''),
        bits.padding || 0,
        hashCount || 0
      );
      for (let i = 0; i < membershipTestResults.length; i++) {
        const backendMembershipResult =
          membershipTestResults[i] === '1' ? true : false;
        const mightContain = bloomFilter.mightContain(documentPrefix + i);
        expect(mightContain).to.equal(backendMembershipResult);
      }
      //Extend default timeout(2000)
    }).timeout(4000);
  });
});
