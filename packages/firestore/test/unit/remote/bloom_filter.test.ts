/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { readFileSync, readdirSync } from 'fs';
import { parse, resolve } from 'path';

import { expect } from 'chai';

import { BloomFilter } from '../../../src/remote/bloom_filter';

var fs = require('fs');
require.extensions['.txt'] = function (module, filename) {
  module.exports = fs.readFileSync(filename, 'utf8');
};

const data: { bits: { bitmap: string, padding: number }, hashCount: number } = require('./bloom_filter_golden_test_data/Validation_BloomFilterTest_MD5_1_01_bloom_filter_proto.json');
const res: string = require('./bloom_filter_golden_test_data/Validation_BloomFilterTest_MD5_1_01_membership_test_result.txt');

describe('zzyzx BloomFilter', () => {
  it('zzyzx can initiate an empty BloomFilter', () => {
    console.log('zzyzx CHECKPOINT 1');
    console.log(`data.bits.bitmap=${data.bits.bitmap}`);
    console.log(`data.bits.padding=${data.bits.padding}`);
    console.log(`data.hashCount=${data.hashCount}`);
    console.log(`res=${res}`);
    console.log('zzyzx CHECKPOINT 2');

    const bloomFilter = new BloomFilter(
      /* bitmap */ new Uint8Array(0),
      /* padding */ 0,
      /* hashCount */ 0
    );
    expect(bloomFilter.getBitSize()).to.equal(0);
  });

  it('can initiate a non empty BloomFilter', () => {
    const bloomFilter = new BloomFilter(
      /* bitmap */ new Uint8Array([151, 153, 236, 116, 7]),
      /* padding */ 3,
      /* hashCount */ 13
    );
    expect(bloomFilter.getBitSize()).to.equal(37);
  });

  it('should throw error if padding is negative', () => {
    try {
      new BloomFilter(new Uint8Array(0), -1, 0);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Padding is negative.'
        )
      ).to.be.true;
    }
  });

  it('should throw error if bitmap size is negative', () => {
    try {
      new BloomFilter(new Uint8Array(0), 1, 0);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Bitmap size is negative.'
        )
      ).to.be.true;
    }
  });

  it('should throw error if hash count is negative', () => {
    try {
      new BloomFilter(new Uint8Array(0), 0, -1);
      expect.fail();
    } catch (error) {
      expect(
        (error as Error)?.message.includes(
          'INTERNAL ASSERTION FAILED: Hash count is negative.'
        )
      ).to.be.true;
    }
  });

  it('mightContain in empty bloom filter should always return false', () => {
    const bloomFilter = new BloomFilter(new Uint8Array(0), 0, 0);
    expect(bloomFilter.mightContain('abc')).to.be.false;
    expect(bloomFilter.mightContain('def')).to.be.false;
  });

  it('mightContain should always return false for empty string', () => {
    const emptyBloomFilter = new BloomFilter(new Uint8Array(0), 0, 0);
    const nonEmptyBloomFilter = new BloomFilter(
      new Uint8Array([151, 153, 236, 116, 7]),
      3,
      13
    );
    expect(emptyBloomFilter.mightContain('')).to.be.false;
    expect(nonEmptyBloomFilter.mightContain('')).to.be.false;
  });

  /**
   * Golden tests are generated by backend based on inserting n number of
   * documents path into Bloom filter.
   *
   * Full documents path is generated by concating documentPrefix and n, ie,
   * projects/project-1/databases/database-1/documents/coll/doc11
   *
   * The test result is generated by checking the membership of documents from
   * documentPrefix+0 to documentPrefix+2n. The membership results from 0 to n
   * is expected to be 1, and from n to 2n to be 0 with some false positive results.
   *
   * The test result of BloomFilter.mightContain() should match the backend result
   * exactly.
   */
  describe('BloomFilter membership test', () => {
    const documentPrefix =
      'projects/project-1/databases/database-1/documents/coll/doc';
    const testDataFolder = 'test/unit/remote/bloom_filter_golden_test_data';

    interface TestDataType {
      bits: {
        bitmap: string;
        padding: number;
      };
      hashCount: number;
    }

    function convertBase64ToUint8Array(base64: string = ''): Uint8Array {
      return Uint8Array.from(atob(base64), item => item.charCodeAt(0));
    }

    it('mightContain result should match backend result', () => {
      readdirSync(testDataFolder).forEach(filename => {
        const ext = parse(filename).ext;

        if (ext === '.json') {
          const testDataPath = resolve(testDataFolder, filename);
          const testResultPath = testDataPath.replace(
            'bloom_filter_proto.json',
            'membership_test_result.txt'
          );
          const testData: TestDataType = JSON.parse(
            readFileSync(testDataPath, 'utf8')
          );
          const testResult: string = readFileSync(testResultPath, 'utf8');
          const { bits = { bitmap: '', padding: 0 }, hashCount = 0 } = testData;
          const bloomFilter = new BloomFilter(
            convertBase64ToUint8Array(bits.bitmap),
            bits.padding || 0,
            hashCount || 0
          );
          for (let i = 0; i < testResult.length; i++) {
            const backendMembershipResult =
              testResult[i] === '1' ? true : false;
            const mightContain = bloomFilter.mightContain(documentPrefix + i);
            expect(mightContain).to.equal(backendMembershipResult);
          }
        }
      });
    });
  });
});
